#cmakedefine USE_BOOST_REGEX

#ifdef USE_BOOST_REGEX
  #include <boost/regex.hpp> // for boost::
#endif

#include "structs.h" // for cmnt_meta

#include "filter_comment_body_regexp.hpp" // for regexpr_str


namespace filter_comment_body {


namespace reason {
    enum {
        NONE,
        UNCONDITIONAL, // i.e. unknown reason
        PROGRAMMING,
        LINUX,
        EGG
    };
}

namespace wl {
// Whitelist

#ifndef USE_BOOST_REGEX
unsigned int match(struct cmnt_meta metadata, const char* str, const int str_len){
    return reason::NONE;
}
#else
const boost::basic_regex<char, boost::cpp_regex_traits<char>> regexpr(regexpr_str, boost::regex::perl);


boost::match_results<const char*> what;


unsigned int match(struct cmnt_meta metadata, const char* str, const int str_len){
    if (!boost::regex_search(str,  str + str_len,  what,  regexpr))
        return reason::NONE;
    
    if (what[GROUP_UNCONDITIONAL].matched  ||  what[GROUP_UNCONDITIONAL].matched)
        // Unconditional
        return reason::UNCONDITIONAL;
    
    if (what[GROUP_PROGRAMMING].matched){
        switch(metadata.subreddit_id){
            // Only accept if from /r/programming
            case 113928: // /r/programming
                return reason::PROGRAMMING;
            default: break;
        }
    }
    
    if (what[GROUP_LINUX].matched){
        return reason::LINUX;
    }
    
    if (what[GROUP_EGG].matched){
        switch(metadata.subreddit_id){
            // Ignore if from /r/videos
            case 4594370: // /r/videos
                break;
            default: return reason::EGG;
        }
    }
    
    return reason::NONE;
}
#endif


}




} // end namespace
